{"version":3,"file":"test-a0e6f645.js","sources":["../../../../lib/prez2.d.ts","../../../../lib/prez2.ts","../../../../stores/rdf2.ts","../../../../pages/test.vue"],"sourcesContent":["export type PrezHeaderLink = {\n    iri: string;\n    rel?: string;\n    title?: string;\n    token?: string;\n    anchor?: string;\n    [key: string]: string | undefined;\n}\n  \nexport type PrezTerm = {\n    dataType?: PrezTerm;\n    termType: 'Literal' | 'NamedNode' | 'BlankNode';\n}\n\nexport type PrezLiteral = PrezTerm & {\n    termType: 'Literal';\n    text: string;\n}\n\nexport type PrezNamedNode = PrezTerm & {\n    termType: 'NamedNode';\n    label?: PrezTerm;\n    description?: PrezTerm;\n    uri: string;\n    curie?: string;\n}\n\nexport type PrezBlankNode = PrezTerm & {\n    termType: 'BlankNode';\n    form: PrezForm;\n}\n\nexport type PrezForm = {\n    config: PrezConfig;\n    class: PrezTerm;\n    title: PrezTerm;\n    description?: PrezTerm;\n    properties: PrezProperties;\n}\n\nexport type PrezConfig = {\n    classPredicates: string[];\n    labelPredicates: string[];\n    descriptionPredicates: string[];\n}\n\nexport type PrezList = {\n    class: PrezTerm;\n    headers: PrezListHeaders;\n    rows: PrezListRows;\n}\n\nexport type PrezListHeaders = Record<string, PrezNamedNode>;\nexport type PrezListRows = Record<string, PrezNamedNode[]>;\n\nexport type PrezProperty = {\n    name: PrezNamedNode;\n    value: PrezTerm|PrezTerm[];\n}\n\nexport type PrezProperties = Record<string, PrezProperty>;\n\nexport const PrezDataFactory = {\n    prezNamedNode(iri: string, label?: PrezTerm, description?: PrezTerm, uri?: string, curie?: string): PrezNamedNode {\n      return {\n        termType: 'NamedNode',\n        uri: uri || iri,\n        label,\n        description,\n        curie,\n      };\n    },\n  \n    prezLiteral(text: string): PrezLiteral {\n      return {\n        termType: 'Literal',\n        text,\n      };\n    },\n  \n    prezBlankNode(form: PrezForm): PrezBlankNode {\n      return {\n        termType: 'BlankNode',\n        form,\n      };\n    },\n  \n    // Add more factory functions for other types as needed\n  };","import { Util, Store, Parser, DataFactory, Quad, NamedNode, type Prefixes, Literal, type Quad_Subject, type OTerm, BlankNode } from \"n3\";\nconst { namedNode } = DataFactory;\nimport axios, { type AxiosRequestConfig } from 'axios';\nimport { PrezDataFactory } from './prez2.d'\nimport type { PrezHeaderLink, PrezBlankNode, PrezForm, PrezLiteral, PrezNamedNode, PrezProperty, PrezTerm, PrezProperties, PrezConfig } from './prez2.d'\nimport { getDefaultLabelFromURIOrString, parseLinkHeader } from \"@/helpers/str\";\nconst { prezNamedNode, prezBlankNode, prezLiteral } = PrezDataFactory;\n\nconst filterRDFType = namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');\nconst filterRDFSLabel = namedNode('http://www.w3.org/2000/01/rdf-schema#label');\n\nexport class Prez {\n  public store: Store;\n  private data: Quad[];\n  private parser: Parser;\n  public prefixes: Prefixes;\n  public headerLinks: PrezHeaderLink[];\n\n  constructor() {\n    this.store = new Store();\n    this.parser = new Parser();\n    this.data = [];\n    this.prefixes = {};\n    this.headerLinks = [];\n  }\n\n  async fetch(url:string, options?: AxiosRequestConfig) {\n    try {\n      \n      const response = await axios(url, options);\n      if (response.status != 200) {\n        throw new Error(`Request failed with status ${response.status}`);\n      }\n      this.headerLinks = parseLinkHeader(response.headers['link']!);\n      await this.load(await response.data);\n\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Error: ${error.message}`);\n      } else {\n        throw new Error(`An unknown error occurred.`);\n      }\n    }\n  }\n\n  async load(rdf: string) {\n    // process the response through the N3 parser\n    await this.parser.parse(rdf, (error, quad, prefixes)=>{\n      if(prefixes) {\n        this.prefixes = prefixes;\n      }\n      if(quad) {\n        this.data.push(quad);\n      }\n    });\n    this.store = new Store(this.data);    \n  }\n\n  expandAll(iri: string[]): string[] {\n    return iri.map(item=>this.expand(item));\n  }\n\n  expand(iri: string): string {\n    // Split the IRI into parts using ':' as the separator\n    const parts = iri.split(':');\n  \n    // Check if the first part (before the first ':') is a valid prefix\n    if (parts.length >= 2 && parts[0] in this.prefixes) {\n      // Replace the prefix with its corresponding IRI\n      parts[0] = this.prefixes[parts[0]].toString();\n  \n      // Join the modified parts back together to form the updated IRI\n      return parts[0] + parts.slice(1).join(':');\n    }\n  \n    return iri;\n  };\n\n  firstQuad(subject: OTerm, predicate: OTerm, object: OTerm | OTerm[], graph: OTerm):Quad|null {\n    const quads = this.store.getQuads(subject, predicate, object, graph);\n    if(quads && quads.length > 0) {\n      return quads[0];\n    } else {\n      return null;\n    }\n  }\n\n  getAnnotation(subject: string, predicates: string[]) {\n\n    console.log(\"LOOKING UP \", subject, predicates)\n    let label:PrezTerm|undefined = undefined;\n    predicates.map(predicate=>{\n      if(label === undefined) {\n        const quad = this.firstQuad(subject, predicate, null, null);\n        if(quad) {\n          label = prezLiteral(quad.object.value);\n        }\n      }\n    });\n    return label;\n  }\n\n  getAnnotated(subject: string, predicateLabels:string[], predicateDescriptions:string[]=[]) {\n\n    return prezNamedNode(\n      subject, \n      this.getAnnotation(subject, predicateLabels), \n      this.getAnnotation(subject, predicateDescriptions),\n      subject, \n      this.compact(subject)\n    );\n\n  }\n\n  expandConfig(config: PrezConfig):PrezConfig {\n    return {\n      classPredicates: this.expandAll(config.classPredicates),\n      labelPredicates: this.expandAll(config.labelPredicates),\n      descriptionPredicates: this.expandAll(config.descriptionPredicates)\n    }\n  }\n\n  form(formConfig: PrezConfig, focusNode=''): PrezForm {\n\n    let focusSubject = focusNode;\n    let focusObject = '';\n    if(focusNode == '') {\n      const typeQuad = this.firstQuad(null, filterRDFType, null, null);\n      if(typeQuad !== null) {\n        focusSubject = typeQuad.subject.value;\n        focusObject = typeQuad.object.value;\n      } else {\n        throw new Error('rdf:type predicate not found');\n      }\n    }\n\n    const config = this.expandConfig(formConfig);\n\n    const form:PrezForm = {\n      config,\n      class: this.getAnnotated(focusObject, config.labelPredicates),\n      properties: {},\n      title: this.getAnnotated(focusSubject, config.labelPredicates, config.descriptionPredicates)\n    };\n\n    return form;\n\n    // const result:Form = {\n    //   formHeaders: {},\n    //   header: {\n    //     label: this.compact(mainObject),//mainHeaderMatches.length > 0 ? mainHeaderMatches[0].object.value : mainShortName,\n    //     iri: mainSubject,\n    //     link: mainSubject\n    //   },\n    //   count,\n    //   fields: {},\n    //   iri: this.compact(mainSubject)\n    // };\n\n    // // expand out predicate labels to full IRI\n    // const expandedPredicateLabels = this.expandAll(labelPredicates);\n    // const expandedPredicateDescriptions = this.expandAll(descriptionPredicates);\n\n    // let s = '';\n\n    // const item = this.getSubjectData(mainSubject, expandedPredicateLabels, expandedPredicateDescriptions);\n\n    // Object.keys(item).filter(field=>field != '_meta').forEach(field=>{\n    //   if(!(field in result.formHeaders)) {\n    //     // ignore internal\n    //     if(mainSubject[0] != '_' || field != 'iri') {\n    //       result.formHeaders[field] = this.getHeader(this.expand(field), item[field]);\n    //     }\n    //   }\n    // })\n    // result.count = Object.keys(result.formHeaders).length;\n\n    // result.fields = item;\n  \n    // return result;\n  }\n\n//   getSubjectData(subject: string, expandedPredicateLabels:string[], expandedPredicateDescriptions:string[]) {\n\n//     const item:ListItem = {\n//       iri: subject,\n//       _meta: {\n//       }\n//     };\n\n//     const matches = this.store.getQuads(subject, null, null, null);\n\n//     for(const mi in matches) {\n//       const match = matches[mi];\n//       const shortName:string = this.compact(match.predicate.value);\n\n//       const meta:any = this.getMeta(match, expandedPredicateLabels, expandedPredicateDescriptions);\n//       console.log(mi, ' = ' + match.object.value);\n\n// //      if(mi == '1') {\n//         console.log(\"XX\")\n//   //    }\n\n//       // recrusive form\n//       if(match.object instanceof BlankNode) {\n        \n//         // initialise the item, ready for many sub items\n//         if(!(shortName in item)) {\n//           item[shortName] = [];\n//         }\n\n//         // recursive lookup...\n//         item[shortName].push(this.form(expandedPredicateLabels, expandedPredicateDescriptions, '_:' + match.object.value));\n//       } else {\n//         const valueQuads = this.store.getQuads(subject, match.predicate.value, null, null);\n\n//         let value:string|string[]|undefined = undefined;//match.predicate.value;\n//         valueQuads.map(valueQuad=>{\n//           const { label, description } = this.getAnnotations(valueQuad.object.value, expandedPredicateLabels, expandedPredicateDescriptions);\n//           const useValue = (label !== undefined ? label : valueQuad.object.value);\n//           if(value !== undefined) {\n//             if(!Array.isArray(value)) {\n//               value = [value];\n//             }\n//             value.push(useValue);\n//           } else {\n//             value = useValue;\n//           }          \n//         })\n//         meta.value = (value === undefined ? match.predicate.value : value);\n//         item[shortName] = meta.value;\n//       }\n//       item._meta![shortName] = meta;\n\n//     }\n  \n//     return item;\n//   }\n\n  getMeta(quad:Quad, predicateLabels:string[], predicateDescriptions:string[]) {\n    const { label, description } = this.getAnnotations(quad.predicate.value, predicateLabels, predicateDescriptions);\n    // lookup data type, if available\n    let type = undefined;\n    let typeIRI = undefined;\n\n    if((quad.object as any).datatype) {\n      console.log(\"DATA TYPE = \", quad.object)\n      typeIRI = (quad.object as any).datatype.value;\n      const typeQuad = this.firstQuad(typeIRI, filterRDFSLabel, null, null);\n      type = getDefaultLabelFromURIOrString(\n        typeQuad !== null && typeQuad.object.value \n          ? typeQuad.object.value.toString()\n          : typeIRI);\n    }\n\n    const meta = {\n      iri: quad.predicate.value,\n      label: label,\n      description,\n      typeIRI,\n      type\n    };\n    return meta;\n\n  }\n\n  // getHeader(subject:string, itemField:any):Header {\n  //   const headerQuad = this.firstQuad(subject, filterRDFSLabel, null, null);\n  //   const head:Header = {\n  //     iri: subject,\n  //     link: filterRDFSLabel.value,\n  //     label: getDefaultLabelFromURIOrString(\n  //       headerQuad !== null && headerQuad.object.value \n  //         ? headerQuad.object.value \n  //         : subject),\n  //     description: ''\n  //   }\n  //   console.log('HEAD=', head, 'ITEM=', itemField)\n  //   return head;\n\n  // }\n\n  getAnnotations(subject: string, predicateLabels:string[], predicateDescriptions:string[]) {\n\n    let label:string|undefined = undefined;\n    let description:string|undefined = undefined;\n\n    predicateLabels.map(predicate=>{\n      if(label === undefined) {\n        const quad = this.firstQuad(subject, predicate, null, null);\n        if(quad) {\n          label = quad.object.value;\n        }\n      }\n    });\n\n    predicateDescriptions.map(predicate=>{\n      if(description === undefined) {\n        const quad = this.firstQuad(subject, predicate, null, null);\n        if(quad) {\n          description = quad.object.value;\n        }\n      }\n    });\n\n    return {\n      label,\n      description \n    }\n  }\n  \n  compact(iri: string): string {\n    for (const prefix in this.prefixes) {\n      if (iri.startsWith(this.prefixes[prefix].toString())) {\n        return `${prefix}:${iri.substring(this.prefixes[prefix].toString().length)}`;\n      }\n    }\n    // to handle standard \"a\" processing\n    if(iri == filterRDFType.value) {\n      return 'rdf:type';\n    }\n    // If no prefix matches, return the original IRI\n    return iri;\n  }\n  \n\n};\n\n// helper functions\n\n","import { acceptHMRUpdate, defineStore } from 'pinia'\n\nimport { type AxiosRequestConfig } from 'axios';\nimport { DataFactory } from \"n3\";\nconst { namedNode } = DataFactory;\nimport { Prez } from '~/lib/prez2';\n\nexport const useRDFStore = defineStore('rdf', {\n  // other options...\n\n  state: ()=>({\n    cache: {} as Record<string, Prez>,\n    loading: false,\n    error: <string|null>'',\n    success: false,\n    prez: <Prez|null>null\n  }),\n\n  actions: {\n    \n    clearCache() {\n      this.cache = {};\n    },\n\n    async load(apiUrl:string, apiConfig?: AxiosRequestConfig) {\n      try {\n        // initialise the state\n        this.loading = true;\n        this.success = false;\n\n\n//        console.log(response.headers.link);\n//        await this.prez.load(response.data);\n\n        const hash = apiUrl + JSON.stringify(apiConfig);\n        if(hash in this.cache) {\n          this.prez = this.cache[hash];\n        } else {\n          this.prez = new Prez();\n          await this.prez.fetch(apiUrl, apiConfig);\n          this.cache[hash] = this.prez as Prez;\n        }\n        // successfully processed\n        this.success = true\n        this.error = null\n\n      } catch (error:any) {\n\n        // set the error status\n        this.error = error.message\n        this.success = false\n\n      } finally {\n        // always set loading to complete\n        this.loading = false\n      }\n    }    \n  },\n\n})\n","<script setup lang=\"ts\">\nimport { useRDFStore } from \"@/stores/rdf2\";\nimport { storeToRefs } from \"pinia\";\nimport { emit } from \"process\";\nimport config from \"~/config\";\nimport type { PrezForm } from \"~/lib/prez2.d\";\n\nconst rdfStore = useRDFStore();\nconst { loading, success, error, prez } = storeToRefs(rdfStore)\n\nconst page = ref(1);\nconst form = ref<PrezForm|undefined>(undefined);\nconst parseError = ref<string|null>(null);\n\nonMounted(async ()=> {\n    await rdfStore.load(config.API_BASE_URL + '/' + config.CATALOG_LIST_URL + '/bblck-ctlg:bblocks',\n        { params: { page: page.value } });\n\n    form.value = prez.value?.form({\n        classPredicates: ['rdf:type'],\n        labelPredicates: ['skos:prefLabel', 'dcterms:title', 'rdfs:label', 'schema:name'],\n        descriptionPredicates: ['skos:definition', 'dcterms:description', 'schema:description']\n    })\n})\n//['http://www.w3.org/1999/02/22-rdf-syntax-ns#type']\n</script>\n<template>\n    OUTPUT:\n<pre>{{ form }}</pre>\n</template>"],"names":[],"mappings":"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"}