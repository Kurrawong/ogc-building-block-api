{"version":3,"file":"rdf-bf33a04b.js","sources":["../../../../lib/prez.ts","../../../../stores/rdf.ts"],"sourcesContent":["import { Util, Store, Parser, DataFactory, Quad, NamedNode, type Prefixes, Literal, type Quad_Subject, type OTerm, BlankNode } from \"n3\";\nconst { namedNode } = DataFactory;\nimport axios, { type AxiosRequestConfig } from 'axios';\nimport type { ListItem, List, HeaderLink, Form, Header } from './prez.d'\nimport { getDefaultLabelFromURIOrString, parseLinkHeader } from \"@/helpers/str\";\n\nconst filterRDFType = namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');\nconst filterRDFSLabel = namedNode('http://www.w3.org/2000/01/rdf-schema#label');\n\nexport class Prez {\n  public store: Store;\n  private data: Quad[];\n  private parser: Parser;\n  public prefixes: Prefixes;\n  public headerLinks: HeaderLink[];\n\n  constructor() {\n    this.store = new Store();\n    this.parser = new Parser();\n    this.data = [];\n    this.prefixes = {};\n    this.headerLinks = [];\n  }\n\n  async fetch(url:string, options?: AxiosRequestConfig) {\n    try {\n      \n      const response = await axios(url, options);\n      if (response.status != 200) {\n        throw new Error(`Request failed with status ${response.status}`);\n      }\n      this.headerLinks = parseLinkHeader(response.headers['link']!);\n      await this.load(await response.data);\n\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Error: ${error.message}`);\n      } else {\n        throw new Error(`An unknown error occurred.`);\n      }\n    }\n  }\n\n  async load(rdf: string) {\n    // process the response through the N3 parser\n    await this.parser.parse(rdf, (error, quad, prefixes)=>{\n      if(prefixes) {\n        this.prefixes = prefixes;\n      }\n      if(quad) {\n        this.data.push(quad);\n      }\n    });\n    this.store = new Store(this.data);    \n  }\n\n  expandAll(iri: string[]): string[] {\n    return iri.map(item=>this.expand(item));\n  }\n\n  expand(iri: string): string {\n    // Split the IRI into parts using ':' as the separator\n    const parts = iri.split(':');\n  \n    // Check if the first part (before the first ':') is a valid prefix\n    if (parts.length >= 2 && parts[0] in this.prefixes) {\n      // Replace the prefix with its corresponding IRI\n      parts[0] = this.prefixes[parts[0]].toString();\n  \n      // Join the modified parts back together to form the updated IRI\n      return parts[0] + parts.slice(1).join(':');\n    }\n  \n    return iri;\n  };\n\n  firstQuad(subject: OTerm, predicate: OTerm, object: OTerm | OTerm[], graph: OTerm):Quad|null {\n    const quads = this.store.getQuads(subject, predicate, object, graph);\n    if(quads && quads.length > 0) {\n      return quads[0];\n    } else {\n      return null;\n    }\n  }\n\n  list(labelPredicates: string[]=[], descriptionPredicates: string[]=[]): List {\n    let mainSubject = '';\n    let subjects: Quad_Subject[] = [];\n    let count = 0;\n\n    const countQuad = this.firstQuad(null, this.expand('prez:count'), null, null);\n    if(countQuad !== null) {\n      count = parseInt(countQuad.object.value);\n      mainSubject = countQuad.subject.value;\n      const predicateFilter = filterRDFType;\n      subjects = this.store.getSubjects(predicateFilter, mainSubject, null);\n    } else {\n      throw new Error('prez:count predicate not found');\n    }\n\n    const mainHeaderMatches = this.store.getQuads(mainSubject, filterRDFSLabel, null, null);\n    const mainShortName:string = this.compact(mainSubject);\n    const result:List = {\n      listHeaders: {},\n      header: {\n        label: mainHeaderMatches.length > 0 ? mainHeaderMatches[0].object.value : mainShortName,\n        iri: mainSubject,\n        link: mainSubject\n      },\n      count,\n      list: [],\n      iri: mainShortName\n    };\n\n    // expand out predicate labels to full IRI\n    const expandedPredicateLabels = this.expandAll(labelPredicates);\n    const expandedPredicateDescriptions = this.expandAll(descriptionPredicates);\n\n    // loop through each item's subject in this list\n    for (const si in subjects) {\n      const subject = subjects[si].value;\n      const item = this.getSubjectData(subject, expandedPredicateLabels, expandedPredicateDescriptions);\n      Object.keys(item).filter(field=>field != '_meta').forEach(field=>{\n        if(!(field in result.listHeaders)) {//} && !(mainSubject.match(/^_:/) && field == 'iri')) {\n          result.listHeaders[field] = this.getHeader(this.expand(field), item[field]);\n        }\n      })\n  \n      result.list.push(item);\n    }\n    return result;\n  }\n\n  form(labelPredicates: string[]=[], descriptionPredicates: string[]=[],  subform?: string): Form {\n\n    console.log(\"FORM\")\n    let count = 0;\n    let mainSubject = subform ? subform : '';\n    let mainObject = '';\n\n    if(mainSubject == '') {\n      const typeQuad = this.firstQuad(null, filterRDFType, null, null);\n      if(typeQuad !== null) {\n        mainSubject = typeQuad.subject.value;\n        mainObject = typeQuad.object.value;\n      } else {\n        throw new Error('rdf:type predicate not found');\n      }\n    }\n\n    const result:Form = {\n      formHeaders: {},\n      header: {\n        label: this.compact(mainObject),//mainHeaderMatches.length > 0 ? mainHeaderMatches[0].object.value : mainShortName,\n        iri: mainSubject,\n        link: mainSubject\n      },\n      count,\n      fields: {},\n      iri: this.compact(mainSubject)\n    };\n\n    // expand out predicate labels to full IRI\n    const expandedPredicateLabels = this.expandAll(labelPredicates);\n    const expandedPredicateDescriptions = this.expandAll(descriptionPredicates);\n\n    let s = '';\n\n    const item = this.getSubjectData(mainSubject, expandedPredicateLabels, expandedPredicateDescriptions);\n\n    Object.keys(item).filter(field=>field != '_meta').forEach(field=>{\n      if(!(field in result.formHeaders)) {\n        // ignore internal\n        if(mainSubject[0] != '_' || field != 'iri') {\n          result.formHeaders[field] = this.getHeader(this.expand(field), item[field]);\n        }\n      }\n    })\n    result.count = Object.keys(result.formHeaders).length;\n\n    result.fields = item;\n  \n    return result;\n  }\n\n  getSubjectData(subject: string, expandedPredicateLabels:string[], expandedPredicateDescriptions:string[]) {\n\n    const item:ListItem = {\n      iri: subject,\n      _meta: {\n      }\n    };\n\n    const matches = this.store.getQuads(subject, null, null, null);\n\n    for(const mi in matches) {\n      const match = matches[mi];\n      const shortName:string = this.compact(match.predicate.value);\n\n      const meta:any = this.getMeta(match, expandedPredicateLabels, expandedPredicateDescriptions);\n      console.log(mi, ' = ' + match.object.value);\n\n//      if(mi == '1') {\n        console.log(\"XX\")\n  //    }\n\n      // recrusive form\n      if(match.object instanceof BlankNode) {\n        \n        // initialise the item, ready for many sub items\n        if(!(shortName in item)) {\n          item[shortName] = [];\n        }\n\n        // recursive lookup...\n        item[shortName].push(this.form(expandedPredicateLabels, expandedPredicateDescriptions, '_:' + match.object.value));\n      } else {\n        const valueQuads = this.store.getQuads(subject, match.predicate.value, null, null);\n\n        let value:string|string[]|undefined = undefined;//match.predicate.value;\n        valueQuads.map(valueQuad=>{\n          const { label, description } = this.getAnnotations(valueQuad.object.value, expandedPredicateLabels, expandedPredicateDescriptions);\n          const useValue = (label !== undefined ? label : valueQuad.object.value);\n          if(value !== undefined) {\n            if(!Array.isArray(value)) {\n              value = [value];\n            }\n            value.push(useValue);\n          } else {\n            value = useValue;\n          }          \n        })\n        meta.value = (value === undefined ? match.predicate.value : value);\n        item[shortName] = meta.value;\n      }\n      item._meta![shortName] = meta;\n\n    }\n  \n    return item;\n  }\n\n  getMeta(quad:Quad, predicateLabels:string[], predicateDescriptions:string[]) {\n    const { label, description } = this.getAnnotations(quad.predicate.value, predicateLabels, predicateDescriptions);\n    // lookup data type, if available\n    let type = undefined;\n    let typeIRI = undefined;\n\n    if((quad.object as any).datatype) {\n      console.log(\"DATA TYPE = \", quad.object)\n      typeIRI = (quad.object as any).datatype.value;\n      const typeQuad = this.firstQuad(typeIRI, filterRDFSLabel, null, null);\n      type = getDefaultLabelFromURIOrString(\n        typeQuad !== null && typeQuad.object.value \n          ? typeQuad.object.value.toString()\n          : typeIRI);\n    }\n\n    const meta = {\n      iri: quad.predicate.value,\n      label: label,\n      description,\n      typeIRI,\n      type\n    };\n    return meta;\n\n  }\n\n  getHeader(subject:string, itemField:any):Header {\n    const headerQuad = this.firstQuad(subject, filterRDFSLabel, null, null);\n    const head:Header = {\n      iri: subject,\n      link: filterRDFSLabel.value,\n      label: getDefaultLabelFromURIOrString(\n        headerQuad !== null && headerQuad.object.value \n          ? headerQuad.object.value \n          : subject),\n      description: ''\n    }\n    console.log('HEAD=', head, 'ITEM=', itemField)\n    return head;\n\n  }\n\n  getAnnotations(subject: string, predicateLabels:string[], predicateDescriptions:string[]) {\n\n    let label:string|undefined = undefined;\n    let description:string|undefined = undefined;\n\n    predicateLabels.map(predicate=>{\n      if(label === undefined) {\n        const quad = this.firstQuad(subject, predicate, null, null);\n        if(quad) {\n          label = quad.object.value;\n        }\n      }\n    });\n\n    predicateDescriptions.map(predicate=>{\n      if(description === undefined) {\n        const quad = this.firstQuad(subject, predicate, null, null);\n        if(quad) {\n          description = quad.object.value;\n        }\n      }\n    });\n\n    return {\n      label,\n      description \n    }\n  }\n  \n  compact(iri: string): string {\n    for (const prefix in this.prefixes) {\n      if (iri.startsWith(this.prefixes[prefix].toString())) {\n        return `${prefix}:${iri.substring(this.prefixes[prefix].toString().length)}`;\n      }\n    }\n    // to handle standard \"a\" processing\n    if(iri == filterRDFType.value) {\n      return 'rdf:type';\n    }\n    // If no prefix matches, return the original IRI\n    return iri;\n  }\n  \n\n};\n\n// helper functions\n\n","import { acceptHMRUpdate, defineStore } from 'pinia'\n\nimport { type AxiosRequestConfig } from 'axios';\nimport { DataFactory } from \"n3\";\nconst { namedNode } = DataFactory;\nimport { Prez } from '~/lib/prez';\n\nexport const useRDFStore = defineStore('rdf', {\n  // other options...\n\n  state: ()=>({\n    cache: {} as Record<string, Prez>,\n    loading: false,\n    error: <string|null>'',\n    success: false,\n    prez: <Prez|null>null\n  }),\n\n  actions: {\n    \n    clearCache() {\n      this.cache = {};\n    },\n\n    async load(apiUrl:string, apiConfig?: AxiosRequestConfig) {\n      try {\n        // initialise the state\n        this.loading = true;\n        this.success = false;\n\n\n//        console.log(response.headers.link);\n//        await this.prez.load(response.data);\n\n        const hash = apiUrl + JSON.stringify(apiConfig);\n        if(hash in this.cache) {\n          this.prez = this.cache[hash];\n        } else {\n          this.prez = new Prez();\n          await this.prez.fetch(apiUrl, apiConfig);\n          this.cache[hash] = this.prez as Prez;\n        }\n        // successfully processed\n        this.success = true\n        this.error = null\n\n      } catch (error:any) {\n\n        // set the error status\n        this.error = error.message\n        this.success = false\n\n      } finally {\n        // always set loading to complete\n        this.loading = false\n      }\n    }    \n  },\n\n})\n"],"names":[],"mappings":"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"}