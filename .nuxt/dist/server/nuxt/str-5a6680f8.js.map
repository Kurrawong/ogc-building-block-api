{"version":3,"file":"str-5a6680f8.js","sources":["../../../../constants.ts","../../../../constantsOverride.ts","../../../../helpers/str.ts"],"sourcesContent":["export const constants = [\n    '{{!bc}}Home',\n    '{{!bc}}Catalogs',\n    '{{!bc}}Collections',\n    '{{!bc}}Items',\n    'Home Page',\n    'View Members',\n    '{{ header.label }} collection',\n    '{{ header.label }} resource'\n] as const;\n\nexport type Texts = typeof constants[number];\n\nexport type OverrideTexts = Partial<Record<Texts, string>>;\n","import { type OverrideTexts } from \"./constants\";\n\nexport default <OverrideTexts>{\n    '{{!bc}}Home': 'Home'\n};\n","import type { HeaderLink } from '~/lib/prez.d'\nimport mustache, { render } from 'mustache';\nimport { constants, type OverrideTexts, type Texts } from '~/constants'\nimport overrides from '~/constantsOverride'\n\nexport function isURI(str: string): boolean {\n  try {\n    new URL(str);\n    return true;\n  } catch (ex) {\n    return false;\n  }\n}\n\n// tests if any uppercase char exists in a string\nexport function containsUppercase(input: string): boolean {\n  const regex = /[A-Z\\p{Lu}]/u;\n  return regex.test(input);\n}\n\n// tests if an uppercase char appears in a word that has at least one lowercase char, e.g. version IRI, returns false\nexport function containsUppercaseInWord(input: string): boolean {\n  // Define a regular expression to match words with at least one lowercase letter\n  const wordWithLowercaseRegex = /\\b[a-z\\p{Ll}]+\\b/u;\n\n  // Find all words that match the regular expression\n  const wordsWithLowercase = input.match(wordWithLowercaseRegex);\n\n  if (wordsWithLowercase) {\n    // Check if any of the matched words contain an uppercase letter\n    for (const word of wordsWithLowercase) {\n      if (/[A-Z\\p{Lu}]/u.test(word)) {\n        return true; // Found an uppercase letter in a word with lowercase\n      }\n    }\n  }\n\n  return false; // No uppercase letter in a word with lowercase\n}\n\nexport function capitalizeFirstLetterIfNoUpperCase(input: string): string {\n  if (containsUppercaseInWord(input)) {\n    return input;\n  } else {\n    return input.charAt(0).toUpperCase() + input.slice(1);\n  }\n}\n\nexport function getDefaultLabelFromURIOrString(uriOrStr: string): string {\n  return uriOrStr;\n  let name = '';\n  try {\n    const urlObject = new URL(uriOrStr);\n    // Check if there is a fragment identifier\n    if (urlObject.hash) {\n      name = urlObject.hash.substring(1).trim(); // Remove the \"#\" symbol\n    }\n    if(name == '') {\n      const pathSegments = urlObject.pathname.split('/').filter(segment => segment !== '');\n      if (pathSegments.length > 0) {\n        name = pathSegments[pathSegments.length - 1];\n      }\n    }\n    if(name == '') {\n      return uriOrStr;\n    }\n  } catch (ex) {\n    name = uriOrStr;\n  }\n  return capitalizeFirstLetterIfNoUpperCase(name);\n}\n\nexport function parseLinkHeader(headerString: string): HeaderLink[] {\n  const headersArray: HeaderLink[] = [];\n\n  if(typeof(headerString) != 'string') {\n    return [];\n  }\n\n  // Split the string by commas and process each header\n  headerString.split(',').forEach(header => {\n    // Extract URI and components\n    const [uri, ...components] = header.split(';').map(item => item.trim());\n\n    // Create an object for the header and set its main key\n    const headerObject: HeaderLink = { iri: uri.replace(/[<>]/g, '') };\n\n    // Process components into key-value pairs\n    components.forEach(component => {\n      const [key, value] = component.split('=');\n      const trimmedKey = key.trim();\n      const trimmedValue = value.replace(/[\"<>]/g, '').trim();\n\n      // Check if the property exists on the object type before setting\n      headerObject[trimmedKey] = trimmedValue;\n    });\n\n    // Store the header object in the array\n    headersArray.push(headerObject);\n  });\n\n  return headersArray;\n}\n\ninterface NestedObject {\n  [key: string]: any;//NestedObject | string | number | boolean | null | Array<any>;\n};\n\nexport const template = (templateString:string, obj:NestedObject) => {\n  const replacedTemplate = templateString.replace(/{{(.*?)}}/g, (match, p1) => {\n    // Replace colons with double underscores within {{ }}\n    const replaced = p1.replace(/:/g, '__');\n    return `{{${replaced}}}`;\n  });\n  return mustache.render(replacedTemplate, transformKeysForMustache(obj));\n};\n\n\nconst transformKeysForMustache = (obj: NestedObject): NestedObject => {\n  const transformedObj: NestedObject = {};\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const value = obj[key];\n\n      // Recursively transform nested objects\n      if (value !== null && typeof value === 'object') {\n        transformedObj[key.replace(/:/g, '__')] = transformKeysForMustache(value as NestedObject);\n      } else {\n        transformedObj[key.replace(/:/g, '__')] = value;\n      }\n    }\n  }\n  transformedObj._debug = Object.keys(transformedObj).map(key=>key.replace('__', ':'));\n  return transformedObj;\n};\n\nexport function tpl(key: Texts, data?: any): string {\n  const str = constants.includes(key)\n    ? key in overrides ? overrides[key]! : key : `\"${key}\" not found`;\n  return (data !== undefined ? template(str, data) : str.replace(/{{\\!.+}}/g, ''));\n}\n"],"names":[],"mappings":";AAAO,MAAM,YAAY;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;ACPA,MAA8B,YAAA;AAAA,EAC1B,eAAe;AACnB;AC4CO,SAAS,+BAA+B,UAA0B;AAChE,SAAA;AAqBT;AAEO,SAAS,gBAAgB,cAAoC;AAClE,QAAM,eAA6B,CAAA;AAEhC,MAAA,OAAO,gBAAiB,UAAU;AACnC,WAAO;EACT;AAGA,eAAa,MAAM,GAAG,EAAE,QAAQ,CAAU,WAAA;AAExC,UAAM,CAAC,KAAK,GAAG,UAAU,IAAI,OAAO,MAAM,GAAG,EAAE,IAAI,CAAQ,SAAA,KAAK,KAAM,CAAA;AAGtE,UAAM,eAA2B,EAAE,KAAK,IAAI,QAAQ,SAAS,EAAE;AAG/D,eAAW,QAAQ,CAAa,cAAA;AAC9B,YAAM,CAAC,KAAK,KAAK,IAAI,UAAU,MAAM,GAAG;AAClC,YAAA,aAAa,IAAI;AACvB,YAAM,eAAe,MAAM,QAAQ,UAAU,EAAE,EAAE;AAGjD,mBAAa,UAAU,IAAI;AAAA,IAAA,CAC5B;AAGD,iBAAa,KAAK,YAAY;AAAA,EAAA,CAC/B;AAEM,SAAA;AACT;AAMa,MAAA,WAAW,CAAC,gBAAuB,QAAqB;AACnE,QAAM,mBAAmB,eAAe,QAAQ,cAAc,CAAC,OAAO,OAAO;AAE3E,UAAM,WAAW,GAAG,QAAQ,MAAM,IAAI;AACtC,WAAO,KAAK,QAAQ;AAAA,EAAA,CACrB;AACD,SAAO,SAAS,OAAO,kBAAkB,yBAAyB,GAAG,CAAC;AACxE;AAGA,MAAM,2BAA2B,CAAC,QAAoC;AACpE,QAAM,iBAA+B,CAAA;AAErC,aAAW,OAAO,KAAK;AACrB,QAAI,OAAO,UAAU,eAAe,KAAK,KAAK,GAAG,GAAG;AAC5C,YAAA,QAAQ,IAAI,GAAG;AAGrB,UAAI,UAAU,QAAQ,OAAO,UAAU,UAAU;AAC/C,uBAAe,IAAI,QAAQ,MAAM,IAAI,CAAC,IAAI,yBAAyB,KAAqB;AAAA,MAAA,OACnF;AACL,uBAAe,IAAI,QAAQ,MAAM,IAAI,CAAC,IAAI;AAAA,MAC5C;AAAA,IACF;AAAA,EACF;AACe,iBAAA,SAAS,OAAO,KAAK,cAAc,EAAE,IAAI,CAAA,QAAK,IAAI,QAAQ,MAAM,GAAG,CAAC;AAC5E,SAAA;AACT;AAEgB,SAAA,IAAI,KAAY,MAAoB;AAClD,QAAM,MAAM,UAAU,SAAS,GAAG,IAC9B,OAAO,YAAY,UAAU,GAAG,IAAK,MAAM,IAAI,GAAG;AAC9C,SAAA,SAAS,SAAY,SAAS,KAAK,IAAI,IAAI,IAAI,QAAQ,aAAa,EAAE;AAChF;"}